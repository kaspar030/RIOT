#!/bin/sh

# uncomment and change this to limit builds, e.g.,
#export BOARDS="samr21-xpro native"
# and / or
#export APPS="examples/hello-world tests/unittests"

export PARTITIONS="${PARTITIONS:-32}"

QUICKBUILD_BOARDS="
adafruit-itsybitsy-m4
atmega256rfr2-xpro
esp32-wroom-32
esp32s3-devkit
frdm-k64f
hifive1b
msb-430
msba2
native
nrf52840dk
qn9080dk
samr21-xpro
stk3200
stm32f429i-disc1"

# this configures boards that are available via pifleet
case "${CI_MURDOCK_PROJECT}" in
    riot)
        : ${TEST_BOARDS_AVAILABLE:="esp32-wroom-32 samr21-xpro"}
        ;;
    riot-staging)
        : ${TEST_BOARDS_AVAILABLE:=""}
        ;;
    *)
        : ${TEST_BOARDS_AVAILABLE:=""}
        ;;
esac

#: ${EMULATED_BOARDS_AVAILABLE:="microbit"}

# temporarily disabling llvm builds until https://github.com/RIOT-OS/RIOT/pull/15595
# is in
: ${TEST_BOARDS_LLVM_COMPILE:="iotlab-m3 native nrf52dk mulle nucleo-f401re samr21-xpro slstk3402a"}

export RIOT_CI_BUILD=1
export CC_NOCOLOR=1
export STATIC_TESTS=0
export CFLAGS_DBG=""
export DLCACHE_DIR=${DLCACHE_DIR:-~/.dlcache}
export ENABLE_TEST_CACHE=${ENABLE_TEST_CACHE:-1}
export MURDOCK_REDIS_HOST=${MURDOCK_REDIS_HOST:-127.0.0.1}

NIGHTLY=${NIGHTLY:-0}

check_label() {
    local label="${1}"
    [ -z "${CI_PULL_LABELS}" ] && return 1
    echo "${CI_PULL_LABELS}" | grep -q "${label}"
    return $?
}

# true if "$2" starts with "$1", false otherwise
startswith() {
  case "${2}" in
    ${1}*) true ;;
    *) false ;;
  esac
}

# this function returns 0 when this build is building a merge queue branch.
is_merge_queue_build() {
    startswith "gh-readonly-queue/" "${CI_BUILD_BRANCH}"
}

# fullbuild logic
# non-full-builds are those where can_fast_ci_run might reduce the build
# automatically
if [ -z "${FULL_BUILD}" ]; then
    if [ "${NIGHTLY}" = 1 ]; then
        FULL_BUILD=1
    elif check_label "CI: full build"; then
        # full build if requested by label
        FULL_BUILD=1
    else
        FULL_BUILD=0
    fi
    export FULL_BUILD
fi


# quickbuild logic
# a "quickbuild" is only building a representative subset of all build
# configurations.
if [ -z "${QUICK_BUILD}" ]; then
    export QUICK_BUILD=0
    if is_merge_queue_build; then
        # always do full build for merge queue' branches
        true
    elif [ ${FULL_BUILD} -eq 1 ]; then
        # full build if building nightly or full build requested by label
        true
    else
        export QUICK_BUILD=1
    fi
fi

# This is a work around for a bug in CCACHE which interacts very badly with
# some features of RIOT and of murdock. The result is that ccache is
# ineffective (i.e. objects are never reused, resulting in extreme cache miss
# rate) and murdock becomes slow.
#
# - CCACHE thinks that -gz by itself enables debugging, which is not true.
#   see https://github.com/ccache/ccache/issues/464
#   - When debug info is included, CCACHE hashes the file paths, as these
#     influence the debug information (the name of compile units and/or their
#     "comp_dir" attribute)
# - Riot does not set -fdebug-prefix-map. This is not that easy as it may not
#   be supported in every toolchain (some are quite old).
# - Murdock builds PRs in different directories each time.
#
# It is only the combination of these three factors which causes this bug.
export OPTIONAL_CFLAGS_BLACKLIST="-gz"

DWQ_ENV="-E BOARDS -E APPS -E NIGHTLY -E RUN_TESTS -E ENABLE_TEST_CACHE
         -E TEST_HASH -E CI_PULL_LABELS -ECI_BASE_BRANCH -ECI_BASE_COMMIT
         -EPKG_USE_MIRROR -EAPPS_CHANGED -EBOARDS_CHANGED -ESTATIC_TESTS
         -E CI_MURDOCK_PROJECT -EFULL_BUILD -EQUICK_BUILD -EPARTITIONS"

if [ ${NIGHTLY} -eq 1 ]; then
    export PKG_USE_MIRROR=0
fi

# if RUN_TESTS is unset (e.g., not passed from the outside),
# set to 1 if NIGHTLY=1 or if the label "CI: run tests" is set,
# otherwise set 0.
if [ -z "$RUN_TESTS" ]; then
    if [ "$NIGHTLY" = "1" ] || check_label "CI: run tests" ; then
        RUN_TESTS=1
    else
        RUN_TESTS=0
    fi
fi

[ "$ENABLE_TEST_CACHE" = "1" ] && {
    check_label "CI: disable test cache" && export ENABLE_TEST_CACHE=0
}

error() {
    echo "$@"
    exit 1
}

# if MURDOCK_HOOK is set, this function will execute it and pass on all it's
# parameters. should the hook script exit with negative exit code, hook() makes
# this script exit with error, too.
# hook() will be called from different locations of this script.
# currently, the only caller is "run_test", which calls "hook run_test_pre".
# More hooks will be added as needed.
hook() {
    if [ -n "${MURDOCK_HOOK}" ]; then
        echo "- executing hook $1"
        "${MURDOCK_HOOK}" "$@" || {
            error "$0: hook \"${MURDOCK_HOOK} $@\" failed!"
        }
        echo "- hook $1 finished"
    fi
}

# true if word "$1" is in list of words "$2", false otherwise
# uses grep -w, thus only alphanum and "_" count as word bounderies
# (word "def" matches "abc-def")
is_in_list() {
    [ $# -ne 2 ] && return 1

    local needle="$1"
    local haystack="$2"

    echo "$haystack" | grep -q -w "$needle"
}

# grep that doesn't return error on empty input
_grep() {
    grep "$@"
    true
}

_greplist() {
    if [ $# -eq 0 ]; then
        echo cat
    else
        echo -n "_grep -E ($1"
        shift
        for i in $*; do
            echo -n "|$i"
        done
        echo ")"
    fi
}

# use dwqc to create full "appdir board toolchain" compile job list
get_compile_jobs() {
    check_label "CI: skip compile test" && return

    local partitions=32

    for i in $(seq 1 ${partitions}); do
        echo "${i}"
    done | dwqc ${DWQ_ENV} --queue default-first -s \
        ${DWQ_JOBID:+--subjob} \
        "echo $0 compile group \${1}:gnu"
}

print_worker() {
    [ -n "$DWQ_WORKER" ] && \
        echo "-- running on worker ${DWQ_WORKER} thread ${DWQ_WORKER_THREAD}, build number $DWQ_WORKER_BUILDNUM."
}

test_hash_calc() {
    local bindir=$1

    # Why two times cut?
    # "test-input-hash.sha1" contains a list of lines containing
    # "<hash> <filename>" on each line.
    # We need to filter out the filename, as it contains the full path name,
    # which differs depending on the build machine.
    #
    # After piping through sha1sum, we get "<hash> -". " -" has to go so we save the
    # hassle of escaping the resulting hash.

    cat ${bindir}/test-input-hash.sha1 | cut -f1 -d' ' | sha1sum | cut -f1 -d' '
}

test_cache_get() {
    test "${ENABLE_TEST_CACHE}" = "1" || return 1
    test -n "$(redis-cli -h ${MURDOCK_REDIS_HOST} get $1)" > /dev/null
}

test_cache_put() {
    redis-cli -h ${MURDOCK_REDIS_HOST} set "$1" ok
}

# compile one app for one board with one toolchain. delete intermediates.
compile() {
    local appdir=$1
    local partition=$(echo $2 | cut -f 1 -d':')
    local toolchain=$(echo $2 | cut -f 2 -d':')

    export BUILD=$(pwd)/build
    export LAZE_JOBS=${JOBS:-8}

    curl -L https://github.com/kaspar030/laze/releases/download/0.1.20/laze-0.1.20-x86_64-unknown-linux-musl.tar.gz | tar -xz --strip-components=1 laze-0.1.20-x86_64-unknown-linux-musl/laze

    ./laze build --global --partition "hash:${partition}/${PARTITIONS}"

    # log some build stats
    if [ -d ${BUILD} ]
    then
        echo "{\"build/\": $(du -s ${BUILD} | cut -f1)}"
    fi

    return $RES
}

# execute static tests
static_tests() {
    print_worker

    [ "$STATIC_TESTS" = "1" ] && \
        ./dist/tools/ci/static_tests.sh
    true
}

get_non_compile_jobs() {
    echo "$0 static_tests"
}

get_jobs() {
    get_non_compile_jobs
    get_compile_jobs
}

$*
