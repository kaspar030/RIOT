/**
 * @defgroup pkg_openwsn   OpenWSN network stack
 * @ingroup  pkg
 * @ingroup  net
 * @brief    Provides a RIOT adaption of the OpenWSN network stack
 * @see      https://github.com/openwsn-berkeley/openwsn-fw
 *
 *
 * # OpenWSN RIOT Port
 *
 * This implementation integrates the [OpenWSN](https://github.com/openwsn-berkeley/openwsn-fw)
 * full stack (UDP, IPv6, RPL, 6TiSCH) into RIOT.
 *
 * This port provides a new RIOT "board" to the OpenWSN software. In this way
 * RIOT's hardware abstraction connects to OpenWSN's interfaces.
 *
 * The simple scheduling mechanism in OpenWSN is run in a RIOT thread with
 * second highest priority after the radio thread (THREAD_PRIORITY_MAIN - 4).
 *
 * The current port of OpenWSN currently needs a root node that works along an
 * external tool that performs routing and handles join procedure:
 * [Openvisualizer](https://github.com/openwsn-berkeley/openvisualizer)
 *
 * ## Joining a network
 *
 * The first thing a new mote will need to do is to find a network. On boot it
 * will actively be listening for enhanced beacons. Once a beacon is received it
 * will adjust its timers drift and synchronize with the network. Re-synchronization
 * will be happening constantly to compensate for oscillator and timer drifts.
 *
 * Once synchronized the node will need to join the network. OpenWSN uses CoJP
 * [constrained join protocol](https://datatracker.ietf.org/doc/draft-ietf-6tisch-minimal-security/)
 * OpenWSN stack only handles Join Requests. The JRC (join registrar/coordinator,
 * a central entity) is not running on the root node, but alongside it, in the
 * `OpenVisualizer` external tool.
 *
 * Once joined the device has the required keys to start listening to DIS (DODAG
 * Information Solicitation) messages and to send DIO (DODAG Information Object)
 * requests. Once it knows about the topology of the network it will be able to
 * send packets.
 *
 * OpenWSN uses source routing. This means that unless the recipient of a packet
 * is one of the parents in the RPL tree the packet will have to go up the tree
 * to the rootnode. But in OpenWSN RPL implementation the node does not know
 * how to route, instead it is `OpenVisualizer` which generates an SRH (Source
 * Routing Header ), attaches to the incoming packet and sends it down the tree.
 *
 * ## Hardware abstraction implementation
 *
 * Following, details about the implementation of selected hardware modules.
 *
 * ### sctimer
 *
 * The `sctimer` ("single compare timer") in OpenWSN is the lowest timer
 * abstraction which is used by the higher layer timer module `opentimers`. In
 * the end it is responsible for scheduling on the MAC layer. To enable low power
 * energy modes, this timer usually uses the RTC (real time clock) or RTT (real
 * time timer) module.
 *
 * In order to get the most portable code, this implementation uses ztimer and
 * defines a new `ztimer_clock` (ZTIMER_32768) that operates at 32768Khz to have
 * a resolution of ~30usec/tick (same as OpenWSN).
 *
 * When available ZTIMER_32768 will be built on top of `periph_rtt` to get low
 * power capabilities. If not it will be built on top of a regular timer. In
 * either case it will be shifted up if the base frequency lower than 32768Hz
 * or frac if higher.
 *
 * The `sctimer` is responsible to set the next interrupt. Under circumstances,
 * it may happen, that the next interrupt to schedule is already late, compared
 * to the current time. In this case, timer implementations in OpenWSN directly
 * trigger a hardware interrupt. In RIOT there is not interface for uart
 * transmit interrupts, and there is not sw interrupts api either. As a
 * workaround a callback is set 0 ticks in the future, which internally will be
 * set to `now + RTT_MIN_VAL`.
 *
 * ### radio
 *
 * The radio adaptation runs in its own thread with the highest priority
 * (`THREAD_PRIORITY_MAIN - 4`) and maps to RIOT's `netdev` API.
 *
 * Hardware MAC layer features such as CSMA/CA, ACK handling and retransmissions
 * are handled by OpenWSN, so the radio driver must support disabling AUTOACK
 * and CSMA handling by the hardware. Frame filtering must as well be disabled.
 *
 * The radio adaptation preloads the buffer so `NETOPT_PRELOADING` must be
 * supported.
 *
 * OpenWSN needs to be notified when a frame reception/transmition starts and
 * when it ends. Therefore radio drivers need to support the following netdev
 * events:
 *
 *     - `NETDEV_EVENT_RX_STARTED`
 *     - `NETDEV_EVENT_TX_STARTED`
 *     - `NETDEV_EVENT_RX_COMPLETE`
 *     - `NETDEV_EVENT_TX_COMPLETE`
 *
 * OpenWSN expects to recover crc information on every received frame even if it
 * will simply drop frames with invalid crc. The stack can function correctly if
 * radio drivers automatically drop frames with an invalid crc (i.e. the stack
 * doesn't get notified about these frames).
 *
 * ### uart
 *
 * In RIOT, the first configured uart device is mapped to STDIO in most cases.
 * In OpenWSN however, the `openserial` tool uses uart to feed external software
 * running on a host computer such as
 * [Openvisualizer](https://github.com/openwsn-berkeley/openvisualizer).
 * To enable use of these tools, a uart adaptation is provided.
 *
 * This is provided through the `openwsn_serial` (`openserial`) module. It
 * will use the next available uart that is not used by STDIO
 * (checking STDIO_UART_DEV). When multiple uart are available STDIO and
 * `openserial` can be used in parallel. If `stdio_null` is used then it will
 * use STDIO_UART_DEV.
 *
 * OpenWSN uart abstraction makes use of tx hardware interrupts to execute a
 * previously registered callback after every byte is sent out. These interrupts
 * are currently not defined in RIOT in a generic way, so instead a timer is set
 * to fire shortly after a byte is written. 
 *
 * It uses `ztimer` to set the timer since its already pulled in as a dependency.
 *
 * ## Tested Platforms and Pin configurations
 *
 * So far, this has been successfully tested on `iotlab-m3`,`nucleo-f103` and
 * `samr21-xpro`, all based on at86rf23x radios.
 *
 * ### Timing
 *
 * Timing is essential for OpenWSN to work properly. For optimal results most
 * parameters in `board_info.h` should be measured for the specific hardware used.
 * OpenWSN has done that for most of their boards. These values can not be taken
 * directly from OpenWSN since they do not necessarily use the same TIMER's or
 * clock speeds.
 *
 * For more details on those parameters refer to:
 * https://openwsn.atlassian.net/wiki/spaces/OW/pages/688251/State+Machine
 *
 * Since all these parameters are HW dependant, it also means that hybrid
 * networks (different type of underlying hardware) might desynchronize often,
 * or not manage to keep in sync at all.
 *
 * ### ledpins & debugpins
 *
 * The OpenWSN software provides different hooks all over the stack to toggle
 * different LEDs as well as debug pins to examine state and scheduling of a node.
 * Default configuration files are provided for both. The LED configuration maps to
 * RIOTs `LEDX_PIN` definitions, if available. On Nucleo boards LED0 line is
 * shared SPI, so is not used.
 * The default configuration can be overwritten by setting `OPENWSN_LEDPINS_DEFAULT`
 * in the form of `ledpins_config_t`. The debugpins work similarly by setting
 * `OPENWSN_DEBUGPINS_BOARD` in the form of `debugpins_config_t`.
 *
 * The default configuration maps to OpenWSN reference hardware `openmote-b`.
 *
 * ## Testing and debugging
 *
 * List of some items which are helpful to explore the functionality of OpenWSN:
 *
 * - LED pins and debug pins as mentioned above in combination with a logic analyzer.
 * The expected behavior is described in:
 * [OpenWSN wiki](https://openwsn.atlassian.net/wiki/spaces/OW/pages/688257/Schedules).
 * - The provided test application provides a UDP client and server. If the UDP
 * server is able to receive packets, the mechanism is considered to work correctly.
 * You should also be able to ping the device from your host. See
 * [tests/pkg_openwsn/README.md](../../tests/pkg_openwsn/README.md) for more details.
 * - To speed up synchronization and make sniffing easier you can disable channel
 * hopping by setting (`CFLAGS=-DIEEE802154E_SINGLE_CHANNEL=26`).
 * - To sniff the packets either use a 802.15.4 capable board and follow
 * [these instructions](https://github.com/RIOT-OS/applications/blob/master/sniffer/tools/README.md).
 * Alternatively use a Raspberry Pi with an external radio such as Openlabs and
 * incorporate Linux WPAN tools. In addition to that, there's also other
 * hardware such as the ATUSB IEEE 802.15.4 USB Adapter which can directly be
 * used on your Linux computer with WPAN tools installed. If you conduct your
 * experiments on the IoT-LAB testbed you might want to use a:
 * [sniffer profile](https://www.iot-lab.info/tutorials/radio-sniffer).
 * - To explore the channel hopping mechanism there are rather expensive
 * multi-channel sniffers such as the BeamLogic 802.15.4 Site Analyzer that can
 * sniff all channels simultaneously. Alternatively you can set up multiple
 * separate sniffer devices locally or make use of the `sniffer_aggregator` on
 * the IoT-LAB testbed.
 * - There is a collection of external tools to interact with the IoT nodes from
 * a host computer via `openserial`. Please refer to the
 * [OpenWSN software](https://github.com/openwsn-berkeley/openwsn-sw) repository
 * for further information.
 *
 * ## Known Issues
 *
 * The following errors will be visible when using `openwsn_serial`:
 *
 * - `[OPENSERIAL] wrong CRC in input Buffer`
 *
 * Since a timer is set to simulate a uart transmit interrupt, it can happen that
 * the interrupt is missed if another interrupt occurs during that time, this
 * seems to lead to the input buffer missing a byte and so CRC fails.
 *
 * - `[IEEE802154E] wdDataDuration overflows while at state 19 in slotOffset 0`
 *
 * This error can show up depending on the distance between the nodes, it seems
 * some of the parameters in board_info.h need further tunning.
 *
 * ## Todos
 *
 * - [ ] `sctimer` to trigger an ISR immediately using software interrupts.
 * - [ ] `RTT_FREQUENCY` is not configurable for most platforms, implementations
 *   should be adapted to make this configurable to be able to set RTT_FREQUENCY
 *   to 32768Hz or the closer possible value.
 * - [ ] The UART wrapper uses ztimer to fake an interrupt after one byte
 *   has been sent. this should also be done with software interrupts.
 *
 * ##  Future Steps
 *
 * The OpenWSN community is working working on refactoring their code base. As
 * one of the outputs of this modules like `cjoin`, `udp`, `coap` will become
 * optional. Once this is upstream the support for this pkg should be adapted.
 *
 * With above mentioned re-works the extraction of the MAC layer might be favored.
 *
 * As more immediate future steps:
 *
 * - [ ] Follow up PR to add OpenWSN sock
 * - [ ] Complete support of OpenWSN default HW (openmote-b)
 * - [ ] Add support for other 802.15.4 network drivers
 *
 */
